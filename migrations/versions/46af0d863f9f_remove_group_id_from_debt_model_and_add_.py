"""Remove group_id from debt model and add group_balance table

Revision ID: 46af0d863f9f
Revises: 82da32f4dda2
Create Date: 2025-07-16 12:49:40.013707

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '46af0d863f9f'
down_revision = '82da32f4dda2'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('group_balance',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('user_id', sa.Integer(), nullable=False),
    sa.Column('group_id', sa.Integer(), nullable=False),
    sa.Column('balance', sa.Float(), nullable=False),
    sa.ForeignKeyConstraint(['group_id'], ['group.id'], name=op.f('fk_group_balance_group_id_group')),
    sa.ForeignKeyConstraint(['user_id'], ['user.id'], name=op.f('fk_group_balance_user_id_user')),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_group_balance')),
    sa.UniqueConstraint('user_id', 'group_id', name=op.f('uq_group_balance_user_id'))
    )
    
    # Data migration: Convert existing group debts to group balances
    connection = op.get_bind()
    
    # Get all group debts (debts with group_id != 1, since 1 is NO_GROUP)
    group_debts = connection.execute(sa.text("SELECT * FROM debt WHERE group_id != 1")).fetchall()
    
    # Calculate group balances from debts
    group_balances = {}
    for debt in group_debts:
        lender_id = debt.lender_id
        borrower_id = debt.borrower_id
        group_id = debt.group_id
        amount = debt.amount
        
        # Initialize balance tracking for this group
        if group_id not in group_balances:
            group_balances[group_id] = {}
        
        # Update lender balance (positive)
        if lender_id not in group_balances[group_id]:
            group_balances[group_id][lender_id] = 0.0
        group_balances[group_id][lender_id] += amount
        
        # Update borrower balance (negative)
        if borrower_id not in group_balances[group_id]:
            group_balances[group_id][borrower_id] = 0.0
        group_balances[group_id][borrower_id] -= amount
    
    # Insert group balances into the new table
    for group_id, user_balances in group_balances.items():
        for user_id, balance in user_balances.items():
            if balance != 0:  # Only insert non-zero balances
                connection.execute(sa.text("""
                    INSERT INTO group_balance (user_id, group_id, balance)
                    VALUES (:user_id, :group_id, :balance)
                """), {"user_id": user_id, "group_id": group_id, "balance": balance})
    
    # Delete all group debts (keep only individual debts where group_id = 1)
    connection.execute(sa.text("DELETE FROM debt WHERE group_id != 1"))
    
    with op.batch_alter_table('debt', schema=None) as batch_op:
        batch_op.drop_constraint('uq_debt_lender_id', type_='unique')
        batch_op.create_unique_constraint(batch_op.f('uq_debt_lender_id'), ['lender_id', 'borrower_id'])
        batch_op.drop_constraint('fk_debt_group_id_group', type_='foreignkey')
        batch_op.drop_column('group_id')

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('debt', schema=None) as batch_op:
        batch_op.add_column(sa.Column('group_id', sa.INTEGER(), nullable=True))
        batch_op.create_foreign_key('fk_debt_group_id_group', 'group', ['group_id'], ['id'])
        batch_op.drop_constraint(batch_op.f('uq_debt_lender_id'), type_='unique')
        batch_op.create_unique_constraint('uq_debt_lender_id', ['lender_id', 'borrower_id', 'group_id'])

    op.drop_table('group_balance')
    # ### end Alembic commands ###
